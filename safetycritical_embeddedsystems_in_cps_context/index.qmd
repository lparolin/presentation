---
title: "Online Map Validation for Autonomous Driving"
subtitle: "An application of Probabilistic Graphical Models"
#title: "Safety-Critical Embedded Systems in Cyber-Physical Context"
author: "Dr. Luca Parolini"
format: 
  revealjs:
    theme: [default, styles.scss]
    html: true
    fig-align: left
    slide-number: true
    include-after-body: custom.js

    title-slide-attributes:
      data-background-image: "images/bg_image_splash.png"  # Path to your image
      data-background-size: cover                   # Ensures full coverage
      data-background-position: center              # Optional: centers image
      data-background-opacity: "0.3"
      data-background-color: "black" 


preview:
  watch-inputs: true

---
## A Journey through Applications of Safe Embedded Systems
- üéì PhD in Electrical & Computer Engineering, Carnegie Mellon University  
- üè≠ 10 :w+ years at BMW AG and GE Global Research  
- üìö Focus: Safety-critical embedded systems, autonomous driving, control theory  
- üîÑ Transition: From applied industrial research to academic impact

## Online Map Validation {background-image="./images/map_validation_bmw_dark.png" .text-light .transparent-background .title-slide}
### Ensuring Safety in DynamicEnvironments

::: {.space-xl}
:::

::: {.text-light}
In collaboration with F. Drost, A. Fabris, and Dr. S. Schneider
:::

## Typical System Architecture for Autonomous-Driving Vehicle 

::: {.columns}
::: {.column width="70%"}
![](images/InfoFlowAutomotive.drawio.svg){fig-align="left" width=100% fig-alt="An example SVG figure"}
:::
:::

Maps play a central role in Autonomous Driving, allowing trajectory adaptation to upcoming road and lane geometry.

The *field of view* (FoV) of maps is extremely large and it is **not** affected by traffic conditions or weather.

::: {.fragment}
Altough potentially very accurate, maps provide data with unknown and potentially extensive latency.

Relying on data from an outdated map may lead to uncomfortable, or even unsafe trajectories.
::: 

:::{.spacer-xs}
:::

:::{.callout-note .no-title .fragment .fade-down}
Maps data must be verified **before** they are used for computing future trajectories.
:::

## Multiple Map Validation Approaches

Depending on the specific application, different approaches to map validation can be considered. ^["Online map validation for autonomous driving", F. Drost, A. Fabris, L. *Parolini*, and S. Schneider, 2020]

<table class="fragmented-table margin-top-mid bottom-border numbered-table top-border">
  <tr>
    <th>#</th>
    <th>Approach</th>
    <th>Details</th>
    <th>Implication</th>
  </tr>
  <tr class="highlightable">
    <td></td>
    <td>**Global Map Invalidation**</td>
    <td>Verifies if a map contain any invalid data. There is no attempt to identify where the map is invalid.</td>
    <td rowspan="2" class="vcenter">A map is valid until proven to be wrong</td>
  </tr>
  <tr class="highlightable">
    <td></td>
    <td>**Local Map Invalidation**</td>
    <td>Attempts to identify which areas of a map contain invalid data</td>
  </tr>
  <tr class="fragment fade-down fragment-index=2">
    <td class="highlightable"></td>
    <td class="highlightable">**Local Map Validation**</td>
    <td class="vcenter highlightable">Every area of a map is invalid until proven to be correct</td>
    <td rowspan="2" class="vcenter">A map is invalid until proven to be correct</td>
  </tr>
  <tr class="fragment fade-down fragment-index=2">
    <td></td>
    <td>**Local Map Correction**</td>
    <td>Use sensor data to correct the map where it is marked as invalid</td>
  </tr>
</table>

:::{.spacer}

:::
::: {.fragment .final-trigger}

In this talk we focus on the problems **1**, **2**, and __3__.
:::
 
## Proposed framework for Online Map Validation - The Big Picture

Here the slide with different label systems, Syamese Network, PGM, and Correlation-Based approach.

## Introduction to Probabilistic Graphical Models

What PGM are, what are nodes and edges
Examples with Rain, Umbrella, and Being Wet


## Use Probabilistic Graphical Model for Map Validation

At run-time we divide the portion of a map relevant for trajectory planning in different sections.

- Every section is associated with a random variable $\mathcal{M}$ representing the validity of the map in that section.
- Validity variables take value: $V$ (*Valid*), or $I$ (*Invalid*).

**The values taken by the variables $M$ are not directly measurable**

:::{.fragment .fade-down .margin-top-small .margin-bottom-small}
We can however observe how well sensor data match data from the map. 
:::


::: {.r-stack style="position: relative; height: 100%;"}
::: {.fragment .fade-down .fade-in-then-out .no-margin-bottom style="position: absolute; top: 0;"}
We focus on

::: {.columns}
::: {.column width="45%" .small-text}
Lane markings
![](images/lane_marking_wide.png){fig-align="left" width=100% fig-alt="Example of lane marking" .no-margin-top}
:::

::: {.column width="5%"}
:::

::: {.column width="45%" .small-text}
Land marks: Traffic lights, building edges, traffic signs.
![](images/landmarks.png){fig-align="left" width=100% fig-alt="Example of landmarks" .no-margin-top}
:::

::: 
:::

::: {.fragment .fade-up style="position: absolute; top: 0;"}
To infer the probability of a section to be valid, we rely on the probability of observing a good match between sensor observation and data from the map.

::: {.spacer}
:::

**Lane and landmarks match** are the observable variables of our model.

<!-- $$P[\textrm{Lane marking match} | \mathcal{M}=V],\quad P[\textrm{Lane marking match} | \mathcal{M}=I]$$
$$P[\textrm{Landmarks match} | \mathcal{M}=V],\quad P[\textrm{Landmarks match} | \mathcal{M}=I]$$
 -->
 
:::
:::

## Proposed PGM for Online Map Validation

Based on expert judgment, we consider a more refined model of cause-effects which account also for:

- Weather affect on accuracy of sensor measurements;
- Error correlation from camera in miss-detecting lane geometry and positions of landmarks;
- Localization errors due to invalid map, or sensors errors.

::: {.fragment}
We consider the following model

::: {.width-40}
```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue];

  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity"];
  LandMarkAccuracy [label="Landmark accuracy"];

  Localization;

  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;
}

```
:::
:::
## Selection of nodes affecting match of lanes and landmark

In the paper we decided to *observe* if lane marking and landmarks had a good match between data from the map and sensor data. 

We also considered the effect of weather on sensor accuracy and the effect of incorrect localization in the probability of having poor matches in lanes and landmarks. 

<script>
  function addNumbersToTables() {
    document.querySelectorAll(".numbered-table tbody").forEach((tbody) => {
      let count = 1;
      tbody.querySelectorAll("tr").forEach((row) => {
        const cell = row.querySelector("td");
        if (cell) {
          cell.textContent = count++;
        }
      });
    });
  }

  function addClassWhenFinalTrigger(class_to_add = "fragments-complete") {
    if (typeof Reveal !== "undefined") {
      // Add class when final trigger is shown
      Reveal.on("fragmentshown", (event) => {
        if (event.fragment.classList.contains("final-trigger")) {
          const slide = event.fragment.closest(".slide");
          slide.classList.add(class_to_add);
        }
      });

      // Remove class when any fragment is hidden
      Reveal.on("fragmenthidden", (event) => {
        const slide = event.fragment.closest(".slide");
        slide.classList.remove(class_to_add);
      });
    }
  }

  function fixSvgSizes() {
    document.querySelectorAll("svg").forEach((svg) => {
      const g = svg.querySelector("g");
      if (!g) return;

      const bbox = g.getBBox();
      const offsetX = -bbox.x;
      const offsetY = -bbox.y;

      // Set viewBox to start at 0,0
      svg.setAttribute("viewBox", `0 0 ${bbox.width} ${bbox.height}`);
      svg.removeAttribute("width");
      svg.removeAttribute("height");
      svg.style.width = "100%";
      svg.style.height = "auto";

      // Apply transform to shift the <g> into the new origin
      g.setAttribute("transform", `translate(${offsetX}, ${offsetY})`);
    });
  }

  function applyDarkenBackground() {
    document.querySelectorAll('.reveal .slides').forEach(slide => {
      if (slide.querySelector('.darken-background')) {
        slide.classList.add('has-darken-background');
      }
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    console.log("JS Functions loaded");
    addNumbersToTables();
    fixSvgSizes();
    addClassWhenFinalTrigger();
    applyDarkenBackground();
  });
</script>


