---
title: "Implementing Probabilistic Graphical Models for Online Map Validation in Autonomous Driving Vehicles"
# author: "Dr. Luca Parolini"
format: 
  revealjs:
    theme: [default, styles.scss]
    html: true
    fig-align: left
    slide-number: true
    auto-animate: true
    number-equations: true
    title-slide-attributes:
      data-background-image: "images/map_validation_bmw.png"  # Path to your image
      data-background-size: cover                   # Ensures full coverage
      data-background-position: center              # Optional: centers image
      data-background-opacity: "0.3"
      data-background-color: "black" 


preview:
  watch-inputs: true

---

## 

::: {.spacer-xl}
:::

::: {.spacer-md}
:::

::: {.columns}
::: {.column width="50%"}
A. Fabris, _L. Parolini_, S. Schneider and A. Cenedese, "**Use of probabilistic graphical methods for online map validation**", IEEE Intelligent Vehicles Symposium (IV2021), Nagoya, Japan, 2021.

Presented at the Second Workshop on Online Map Validation and Road Model Creation.

([**MaVRoC 2021**](https://map-validation.github.io/2021/)).

:::

::: {.column width="50%"}
![](images/mavroc_screenshot_2021.png){fig-align="left" width=100% fig-alt="MaVRoC 2021"}

:::


:::



::: {.spacer-xl}
:::

::: {.spacer-xl}
:::

In collaboration with Dept. of Information Engineering, University of Padova, Padua, Italy.


## The role of Maps in Autonomous-Driving Vehicle 

- Maps play a central role in autonomous driving, enabling vehicles to adapt their trajectories to upcoming road and lane geometry.

- The  _Field of View_ (FoV) of maps is extremely large and remains unaffected by traffic conditions or weather.

::: {.columns}
::: {.column width="50%"}
![**Simplified Architecture for Autonomous Driving Vehicles.**](images/information_flow_autonomous_driving){fig-align="left" width=100% fig-alt="Simplified architecture for Autonomous Driving Vehicles."}
:::
:::



:::{.spacer-xs}
:::

::: {.fragment}
Although potentially very accurate, maps provide data with unknown and potentially extensive latency.

Relying on data from an outdated map may lead to uncomfortable, or even unsafe trajectories.
::: 

:::{.callout-note .no-title .fragment .fade-down}
Maps data must be verified **before** they are used for computing future trajectories.
:::

## Different Map Validation Approaches

Depending on the specific application, different approaches to map validation can be considered. ^["F. Drost, A. Fabris, L. *Parolini*, and S. Schneider "Online map validation for autonomous driving", 2020]

<table class="fragmented-table margin-top-mid bottom-border numbered-table top-border">
  <tr>
    <th>#</th>
    <th>Approach</th>
    <th>Details</th>
    <th>Implication</th>
  </tr>
  <tr class="highlightable">
    <td></td>
    <td>**Global Map Invalidation**</td>
    <td>Verifies if a map contain any invalid data. There is no attempt to identify where the map is invalid.</td>
    <td rowspan="2" class="vcenter">A map is valid until proven to be wrong</td>
  </tr>
  <tr class="highlightable">
    <td></td>
    <td>**Local Map Invalidation**</td>
    <td>Attempts to identify which areas of a map contain invalid data</td>
  </tr>
  <tr class="fragment fade-down fragment-index=2">
    <td class="highlightable"></td>
    <td class="highlightable">**Local Map Validation**</td>
    <td class="vcenter highlightable">Every area of a map is invalid until proven to be correct</td>
    <td rowspan="2" class="vcenter">A map is invalid until proven to be correct</td>
  </tr>
  <tr class="fragment fade-down fragment-index=2">
    <td></td>
    <td>**Local Map Correction**</td>
    <td>Use sensor data to correct the map where it is marked as invalid</td>
  </tr>
</table>

:::{.spacer}

:::
::: {.fragment .final-trigger}

In this talk we focus on the problems **1**, **2**, and __3__.
:::
 
## Proposed probabilistic framework {auto-animate="true"}


::: {.columns}
::: {.column width="50%" .mid-space}

::: {.spacer-md}
:::

- Autonomous-driving vehicles are equipped with multiple sensors
  - Each sensor observes a different part of the road

- Different algorithms combine data from selected sensors and provide an estimation of the map validity in given **areas**
  - We call these algorithms _labelling systems_

- A **correlation-based approach** fuses the results from the different algorithms^[Fabris _et al._ "Correlation-Based Approach to Online Map Validation", MaVRoC 2020, IEEE IV2020] across different areas, providing a unified view of map validity.

::: {.spacer-lg}
:::

::: {.fragment}
In this work, we focus on a labelling system built on **Probabilistic Graphical Models_ (PGMs)**
:::

:::

:::{.column width="50%"}

![](images/prob_framework.png){fig-align="right" width=90% fig-alt="Proposed probabilistic framework"}


![Example of map validation in multiple areas of the road model](images/map_validation_bmw){fig-align="right" width=90% fig-alt="Example of map validation based on correlation"}

:::
:::


## Using Probabilistic Graphical Model for Map Validation

At run time, we divide the portion of a map relevant for trajectory planning into multiple sections.

- Every section is associated with a random variable $\mathcal{M}$ representing the validity of the map in that section.
  - Every section is either: _Valid_, or _Invalid_
- **The values taken by $\mathcal{M}$ are not directly observable**.


::: {.r-stack style="position: relative; height: 100%;"}
::: {.fragment .fade-in-then-out .no-margin-bottom style="position: absolute; top: 0;"}

Our observable variables are the **matches** between sensor‑measured positions of landmarks and lanes, and their expected positions according to the map.

::: {.columns}
::: {.column width="45%" .small-text}
![Lane markings](images/lane_marking_wide.png){fig-align="left" width=100% fig-alt="Example of lane marking" .no-margin-top}

:::


::: {.column width="45%" .small-text}
![Land marks: Traffic lights, building edges, traffic signs.](images/landmarks.png){fig-align="left" width=100% fig-alt="Example of landmarks" .no-margin-top}
:::
:::

:::

::: {.fragment .fade-up style="position: absolute; top: 0;"}
We propose the following _Probabilistic Graphical Model_ (PGM). 

::: {.columns}
::: {.column width="65%"}

```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue];
  Lidar [label="Lidar status"]
  Camera [label="Camera status"]
  Radar [label="Radar status"]


  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity"];
  LandMarkAccuracy [label="Landmark accuracy"];

  Localization[label="Localization\naccuracy"]

  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;
}

```



:::
::: {.column width="35%"}

- Nodes represent random variables
- Edges represent direct influences between random variables

::: {.spacer-sm}
:::

::: 
:::
:::
:::


## Use Probabilistic Graphical Model for Map Validation

At run time, we divide the portion of a map relevant for trajectory planning into multiple sections.

- Every section is associated with a random variable $\mathcal{M}$ representing the validity of the map in that section.
  - Every section is either: _Valid_, or _Invalid_
- **The values taken by $\mathcal{M}$ are not directly measurable**.


We propose the following _Probabilistic Graphical Model_ (PGM). 

::: {.columns}
::: {.column width="65%"}
```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue];
  Lidar [label="Lidar status"]
  Camera [label="Camera status"]
  Radar [label="Radar status"]


  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity"];
  LandMarkAccuracy [label="Landmark accuracy"];

  Localization;
  MeasurableNodeLaneMarking [label="Measurable node", shape=plaintext, fontcolor=darkgreen,  fontsize=18];

  Localization[label="Localization\naccuracy"]


  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;


  // New node + arrow
  MeasurableNodeMap [label="Measurable\lnode\l", shape=plaintext, fontcolor=darkgreen,  fontsize=18, fontname="Helvetica-Bold"];
  MeasurableNodeLandMark [label="Measurable\lnode\l", shape=plaintext, fontcolor=darkgreen,  fontsize=18, fontname="Helvetica-Bold"];
  MeasurableNodeLaneMarking [label="Measurable\lnode\l", shape=plaintext, fontcolor=darkgreen,  fontsize=18, fontname="Helvetica-Bold"];
  
   // Force same horizontal rank
  { rank=same; MeasurableNodeMap; Weather }
   // Force same horizontal rank
  { rank=same; MeasurableNodeLandMark; MeasurableNodeLaneMarking, LaneMarkingMatch, LandMarkMatch }


  MeasurableNodeMap -> Weather [color=darkgreen, penwidth=2];
  MeasurableNodeLandMark -> LandMarkMatch
  MeasurableNodeLaneMarking ->LaneMarkingMatch
}

```

:::
::: {.column width="35%"}

- Nodes represent random variables
- Edges represent direct influences between random variables

::: {.spacer-sm}
:::


- _Weather_, _Lane marking match_, and _Landmark match_ are **measurable nodes**

::: {.spacer-sm}
:::


::: {.fragment}

- All random variables are modelled as discrete.
:::
:::
:::


## Examples of prior and conditional distributions {auto-animate="true"}

::: {.columns}
::: {.column width="30%" }

:::{data-id="replaceme"}

Prior distributions for **Weather** and **Map Validity**

:::{.small-text}
Weather

<table class="top-border bottom-border table-left .tiny-text">
  <tr>
    <td>**Value**</td>
    <td>**Probability**</td>
  </tr>
  <tr>
    <td>_Cooperative_</td>
    <td>0.5</td>
  </tr>
  <tr>
    <td>_Non-cooperative_</td>
    <td>0.5</td>
  </tr>
  
</table>

:::{.spacer-lg}
:::

Map Validity

<table class="top-border bottom-border table-left .tiny-text">
  <tr>
    <td>**Value**</td>
    <td>**Probability**</td>
  </tr>
  <tr>
    <td>_Valid_</td>
    <td>0.8</td>
  </tr>
  <tr>
    <td>_Invalid_</td>
    <td>0.2</td>
  </tr>
  
</table>

:::
:::
:::

:::{.column width="70%"}

```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue, color=darkred, penwidth=5, fontname="Helvetica-Bold"];
  Lidar [label="Lidar status"]
  Camera [label="Camera status"]
  Radar [label="Radar status"]


  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity", color=darkred, penwidth=5, fontname="Helvetica-Bold"];
  LandMarkAccuracy [label="Landmark accuracy"];

  Localization;

  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  Localization[label="Localization\naccuracy"]

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;

}

```

:::
:::


## Examples of prior and conditional distributions {auto-animate="true"}

::: {.columns}
::: {.column width="55%"}

Conditional distributions for Lane marking and Landmark accuracy having high accuracy^[All parameter values available at [GitHub/lparolin/mavroc_2021](https://github.com/lparolin/mavroc_2021/blob/main/mavroc_2021.ipynb)]

:::{data-id="replaceme"}

:::{.small-text}
<table class="top-border bottom-border table-left .tiny-text">
  <tr>
    <td>**Variable**</td>
    <td>**Camera**</td>
    <td>**Radar**</td>
    <td>**Lidar**</td>
    <td>**Probability**</td>
  </tr>
  <tr>
    <td .vcenter rowspan="2" >Lane marking accuracy</td>
    <td>Nominal</td>
    <td>-</td>
    <td>-</td>
    <td>0.85</td>
  </tr>
  <tr>
    <td>**Degraded**</td>
    <td>-</td>
    <td>-</td>
    <td>0.3</td>
  </tr>

  <tr>
    <td .vcenter rowspan="8" >Landmark accuracy</td>
    <td>Nominal</td>
    <td>Nominal</td>
    <td>Nominal</td>
    <td>0.95</td>
  </tr>
  <tr>
    <td>**Degraded**</td>
    <td>Nominal</td>
    <td>Nominal</td>
    <td>0.8</td>
  </tr>
  <tr>
    <td>Nominal</td>
    <td>**Degraded**</td>
    <td>Nominal</td>
    <td>0.8</td>
  </tr>
  <tr>
    <td>**Degraded**</td>
    <td>**Degraded**</td>
    <td>Nominal</td>
    <td>0.4</td>
  </tr>
  <tr>
    <td>Nominal</td>
    <td>Nominal</td>
    <td>**Degraded**</td>
    <td>0.7</td>
  </tr>
  <tr>
    <td>**Degraded**</td>
    <td>Nominal</td>
    <td>**Degraded**</td>
    <td>0.7</td>
  </tr>
  <tr>
    <td>Nominal</td>
    <td>**Degraded**</td>
    <td>**Degraded**</td>
    <td>0.5</td>
  </tr>
  <tr>
    <td>**Degraded**</td>
    <td>**Degraded**</td>
    <td>**Degraded**</td>
    <td>0.01</td>
  </tr>

</table>

:::
:::
:::

:::{.column width="45%"}

:::{.spacer-sm}
:::

:::{.spacer-lg}
:::


```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue];
  Lidar [label="Lidar status"]
  Camera [label="Camera status"]
  Radar [label="Radar status"]


  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy",  color=darkred, penwidth=5, fontname="Helvetica-Bold"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity"];
  LandMarkAccuracy [label="Landmark accuracy", color=darkred, penwidth=5, fontname="Helvetica-Bold"];

  Localization[label="Localization\naccuracy"];

  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;

}

```

:::
:::



## Examples of prior and conditional distributions {auto-animate="true"}

::: {.columns}
::: {.column width="55%"}

Conditional distributions for Localization having high accuracy^[All parameter values available at [GitHub/lparolin/mavroc_2021](https://github.com/lparolin/mavroc_2021/blob/main/mavroc_2021.ipynb)]

:::{data-id="replaceme"}

:::{.small-text}
<table class="top-border bottom-border table-left .tiny-text">
  <tr>
    <td>**Variable**</td>
    <td>**Lane marking accuracy**</td>
    <td>**Map Validity**</td>
    <td>**Landmark accuracy is high**</td>
    <td>**Probability**</td>
  </tr>
  
  <tr>
    <td .vcenter rowspan="8" >Localization accuracy</td>
    <td>High</td>
    <td>Valid</td>
    <td>High</td>
    <td>0.95</td>
  </tr>
  <tr>
    <td>High</td>
    <td>Valid</td>
    <td>**Low**</td>
    <td>0.7</td>
  </tr>
  <tr>
    <td>High</td>
    <td>**Invalid**</td>
    <td>High</td>
    <td>0.1</td>
  </tr>
  <tr>
    <td>High</td>
    <td>**Invalid**</td>
    <td>**Low**</td>
    <td>0.1</td>
  </tr>
  <tr>
    <td>**Low**</td>
    <td>Valid</td>
    <td>High</td>
    <td>0.8</td>
  </tr>
  <tr>
    <td>**Low**</td>
    <td>Valid</td>
    <td>**Low**</td>
    <td>0.2</td>
  </tr>
  <tr>
    <td>**Low**</td>
    <td>**Invalid**</td>
    <td>High</td>
    <td>0.1</td>
  </tr>
  <tr>
    <td>**Low**</td>
    <td>**Invalid**</td>
    <td>**Low**</td>
    <td>0.1</td>
  </tr>

</table>

:::
:::
:::

:::{.column width="45%"}

:::{.spacer-sm}
:::

:::{.spacer-lg}
:::


```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue];
  Lidar [label="Lidar status"]
  Camera [label="Camera status"]
  Radar [label="Radar status"]


  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity"];
  LandMarkAccuracy [label="Landmark accuracy"];

  Localization[label="Localization\naccuracy", color=darkred, penwidth=5, fontname="Helvetica-Bold"];

  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;

}

```

:::
:::


## Computation of posterior distribution of Map Validity

For every area, and at every iteration we want to compute

$$
\begin{equation}
P(M =\textrm{Valid}\mid W, S_{\mathrm{lane}}, S_{\mathrm{land}})
=
\frac{P(M, W, S_{\mathrm{lane}}, S_{\mathrm{land}})}
     {P(W, S_{\mathrm{lane}}, S_{\mathrm{land}})},
\label{eq:posterior}
\end{equation}
$$ {#eq-posterior-map}

where 

- $M$ represents the validity of map (valid, invalid)
- $W$ represents the weather status (cooperative, Non-cooperative)
- $S_{\mathrm{lane}}$ represents the matching of lane markings (detected, not-detected) and
- $S_{\mathrm{land}}$ represents the matching of landmarks (detected, not-detected).

:::{.fragment .fade-up}
These probabilities can be obtained from the graphical model by marginalizing over the hidden variables.

- Circa 1k FLOPs per area

:::

:::{.spacer-lg}
:::

:::{.fragment .fade-up}
When all conditional probabilities are constant, then **a look-up table** approach can be used. 
:::
<!-- 
## Posterior probabilities of high accuracy for different observations {auto-animate="true"}

![](images/posterior_hidden_variables.png){width=90% fig-alt="Posterior probability of high accuracy"} -->

## Posterior probabilities of high accuracy under different observations {auto-animate="true"}

![](images/posterior_map_validity.png){width=90% fig-alt="Posterior probability of high accuracy and map validity"}

# From a probability distribution to a classifier{background-image="images/map_validation_bmw_dark.png"  .transparent-background .text-light}


## The proposed classifier
- The algorithm discussed till now, computes the posterior distribution of valid map, given a certain input from the measured nodes
- **We still need a rule to decide whether a map should be classified as valid, based on the posterior distribution**

:::{.fragment}

- **Proposed classifier**: a map is classified as valid if the posterior probability of being valid exceeds $\lambda$
  - If $\lambda=0$, then a map is always classified as valid,
  - If $\lambda=1$, then a map is never classified as valid.
:::


## The proposed classifier

- The algorithm discussed till now, computes the posterior distribution of valid map, given a certain input from the measured nodes
- **We still need a rule to decide if a map is as valid based on the posterior distribution**


- **Proposed classifier**: a map is classified as valid if the posterior probability of being valid exceeds $\lambda$
  - If $\lambda=0$, then a map is always classified as valid,
  - If $\lambda=1$, then a map is never classified as valid.

::: {.columns}

:::{.column width="70%"}

:::{data-id="lambda_plot"}
![](images/map_valid_lambda_0_8.png){width=100% fig-alt="Posterior probability of high accuracy and map validity"}
:::

:::

::: {.column width="30%"}

:::{.spacer-xl}
:::

- When $\lambda=0.8$, then the map is classified as valid in these cases only

:::

:::

## Receiver operating characteristic (ROC) curve for the classifier


::: {.columns}
::: {.column width="45%" .mid-space}
:::{.spacer-lg}
:::

- Pairs of _False Positive Rate_ (FPR),  _True Positive Rate_ (TPR) for different values of $\lambda$
  - FPR: Probability of declaring a map valid, when it is **not** valid
  - TPR: Probability of declaring a map valid, when it is valid

- The pair (FPR=0.1; TPR=0.85) means: 
  - an invalid map is classified as valid 10% of time,
  - a valid map is classified as invalid 15% of time.

:::{.spacer-sm}
:::

- The proposed approach is rather insensitive to the value of $\lambda$

:::

::: {.column width="5%" .mid-space}

:::

::: {.column width="50%"}

![](images/roc_curve2.png){fig-alt="ROC Curve"}
:::

:::

## Conclusion and future research

::: {.spacer-md}
:::

- Probabilistic Graphical Models (PGMs) can be effectively applied to online map validation
  - By relying on discrete variables, most computations can be pre‑computed offline
  
::: {.spacer-sm}
:::

- Data from heterogeneous sources can be fused within a unified probabilistic framework
  - The network provides the posterior distribution for all variables in the model
  - Internal nodes retain a clear probabilistic interpretation

::: {.spacer-sm}
:::


- Compared with deep‑learning techniques, PGMs require fewer data to tune their parameters
  - Some of these data can be learned from experiments, others may require expert judgment

::: {.spacer-lg}
:::

- Sensitivity to model parameters not investigated yet
  - Comparison against alternative approaches, e.g., based on neural networks, remains pending

# Questions? {background-image="images/map_validation_bmw_dark.png"  .transparent-background .text-light}

# Backup

## Algorithm steps

![**Steps for lane marking match.**](images/Information_flow_lane_marking.svg){width="80%" fig-alt="Information flow lane marking match"}

![**Steps for landmark match.**](images/landmark_match.svg){width="80%" fig-alt="Information flow lane marking match"}






<script>
  function addNumbersToTables() {
    document.querySelectorAll(".numbered-table tbody").forEach((tbody) => {
      let count = 1;
      tbody.querySelectorAll("tr").forEach((row) => {
        const cell = row.querySelector("td");
        if (cell) {
          cell.textContent = count++;
        }
      });
    });
  }

  function addClassWhenFinalTrigger(class_to_add = "fragments-complete") {
    if (typeof Reveal !== "undefined") {
      // Add class when final trigger is shown
      Reveal.on("fragmentshown", (event) => {
        if (event.fragment.classList.contains("final-trigger")) {
          const slide = event.fragment.closest(".slide");
          slide.classList.add(class_to_add);
        }
      });

      // Remove class when any fragment is hidden
      Reveal.on("fragmenthidden", (event) => {
        const slide = event.fragment.closest(".slide");
        slide.classList.remove(class_to_add);
      });
    }
  }

  function fixSvgSizes() {
    document.querySelectorAll("svg").forEach((svg) => {
      const g = svg.querySelector("g");
      if (!g) return;

      const bbox = g.getBBox();
      const offsetX = -bbox.x;
      const offsetY = -bbox.y;

      // Set viewBox to start at 0.0
      svg.setAttribute("viewBox", `0 0 ${bbox.width} ${bbox.height}`);
      svg.removeAttribute("width");
      svg.removeAttribute("height");
      svg.style.width = "100%";
      svg.style.height = "auto";

      // Apply transform to shift the <g> into the new origin
      g.setAttribute("transform", `translate(${offsetX}, ${offsetY})`);
    });
  }

  function applyDarkenBackground() {
    document.querySelectorAll('.reveal .slides').forEach(slide => {
      if (slide.querySelector('.darken-background')) {
        slide.classList.add('has-darken-background');
      }
    });
  }


  function animateTransition(srcId, dstId) {
  const src = document.getElementById(srcId);
  const dst = document.getElementById(dstId);
  if (!src || !dst) {
    console.warn('animateTransition: src or dst not found', srcId, dstId);
    return;
  }

  // Remove any previous clone
  document.querySelectorAll('.transition-clone').forEach(el => el.remove());

  const srcRect = src.getBoundingClientRect();
  const dstRect = dst.getBoundingClientRect();

  const dx = dstRect.left - srcRect.left;
  const dy = dstRect.top - srcRect.top;
  const scaleX = dstRect.width / srcRect.width;
  const scaleY = dstRect.height / srcRect.height;

  // Create clone
  const clone = src.cloneNode(true);
  clone.classList.add('transition-clone');
  Object.assign(clone.style, {
    position: 'fixed',
    left: `${srcRect.left}px`,
    top: `${srcRect.top}px`,
    width: `${srcRect.width}px`,
    height: `${srcRect.height}px`,
    margin: '0',
    transform: 'translate(0px, 0px) scale(1, 1)',
    transition: 'transform 0.6s ease-in-out, opacity 0.3s ease-in',
    zIndex: '9999',
    pointerEvents: 'none',
    opacity: '1',
    willChange: 'transform, opacity'
  });

  document.body.appendChild(clone);

  // Hide real dst initially
  dst.style.visibility = 'hidden';

  // Log for diagnostics
  console.log('Initial:', { srcRect, dstRect });

  // Listen for transform transition end on clone
  let transformDone = false;
  clone.addEventListener('transitionend', (e) => {
    if (e.propertyName === 'transform') {
      transformDone = true;
      console.log('transform transition ended; clone bbox:', clone.getBoundingClientRect());
      // After transform ends, we trigger the fade
      // But wait a tiny bit (or next frame) so browser is stable
      requestAnimationFrame(() => {
        // Fade in dst
        dst.style.visibility = 'visible';
        dst.style.opacity = '1';
        dst.style.transition = 'opacity 0.3s ease-in';

        // Fade out the clone
        clone.style.opacity = '0';
      });
    }
  });

  // Start the animation
  requestAnimationFrame(() => {
    console.log('Applying transform:', `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`);
    clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
  });

  // After fade-out ends, clean up
  clone.addEventListener('transitionend', (e) => {
    if (e.propertyName === 'opacity' && transformDone) {
      console.log('opacity transition ended; removing clone; final clone bbox:', clone.getBoundingClientRect(), 'dst bbox:', dst.getBoundingClientRect());
      clone.remove();
    }
  });
}

/**
 * Animate an element moving from srcEl to dstEl,
 * fading out clone during last 20% of movement,
 * and fading in destination element smoothly.
 * 
 * @param {HTMLElement} srcEl - The source element to clone and animate from.
 * @param {HTMLElement} dstEl - The destination element to animate to.
 * @param {Object} [options] - Optional timing settings in ms.
 * @param {number} [options.duration=600] - Total duration of transform animation.
 * @param {number} [options.fadeOutStartRatio=0.8] - When to start fading out clone (as ratio of duration).
 * @param {number} [options.fadeDuration=120] - Duration of clone fade out.
 * @param {number} [options.dstFadeDuration=200] - Duration for destination fade in.
 */
function animateElementTransition(srcId, dstId, options = {}) {
  const {
    duration = 500,
    fadeOutStartRatio = 0.2,
    fadeDuration = 200,
    dstFadeDuration = 900,
  } = options;

  if (!srcId || !dstId) return;
  const srcEl = document.getElementById(srcId);
  const dstEl = document.getElementById(dstId);
  if (!srcEl || !dstEl) {
    console.warn('animateTransition: src or dst not found', srcId, dstId);
    return;
  }
  // Measure source and destination positions/sizes
  const srcRect = srcEl.getBoundingClientRect();
  const dstRect = dstEl.getBoundingClientRect();

  // Hide and set destination opacity 0 initially
  dstEl.style.visibility = 'hidden';
  dstEl.style.opacity = '0';
  dstEl.style.transition = `opacity ${dstFadeDuration}ms ease`;

  // Clone source element
  const clone = srcEl.cloneNode(true);

  Object.assign(clone.style, {
    position: 'fixed',
    top: `${srcRect.top}px`,
    left: `${srcRect.left}px`,
    width: `${srcRect.width}px`,
    height: `${srcRect.height}px`,
    margin: '0',
    transformOrigin: 'top left',
    transition: `transform ${duration}ms ease, opacity ${fadeDuration}ms linear`,
    zIndex: 9999,
    pointerEvents: 'none',
    boxSizing: 'border-box',
    opacity: '1',
    background: 'white', // or adjust for SVG/transparent backgrounds
    willChange: 'transform, opacity',
  });

  document.body.appendChild(clone);
  clone.getBoundingClientRect(); // force reflow

  // Compute transform delta and scale
  const dx = dstRect.left - srcRect.left;
  const dy = dstRect.top - srcRect.top;
  const scaleX = dstRect.width / srcRect.width;
  const scaleY = dstRect.height / srcRect.height;

  // Start transform animation
  requestAnimationFrame(() => {
    clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
  });

  // Schedule fade out of clone starting at fadeOutStartRatio * duration
  setTimeout(() => {
    clone.style.opacity = '0';
  }, duration * fadeOutStartRatio);

  // Cleanup and reveal destination when fade out ends
  clone.addEventListener('transitionend', function onTransitionEnd(e) {
    if (e.propertyName === 'opacity' && clone.style.opacity === '0') {
      // Show and fade in destination
      dstEl.style.visibility = 'visible';
      dstEl.style.opacity = '1';

      clone.removeEventListener('transitionend', onTransitionEnd);
      clone.remove();
    }
  });
}


  function setupRevealTransitions() {
    const srcElements = Array.from(document.querySelectorAll('[id$="_src"]'));

    srcElements.forEach(src => {
      const baseId = src.id.replace(/_src$/, '');
      const dst = document.getElementById(`${baseId}_dst`);
      if (!dst) return;

      const fragmentAncestor = dst.closest('.fragment');

      const trigger = () => {
        requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          //animateTransition(`${baseId}_src`, `${baseId}_dst`);
          animateElementTransition(`${baseId}_src`, `${baseId}_dst`);
          });
        });
      };

      if (fragmentAncestor) {
        Reveal.addEventListener('fragmentshown', event => {
          if (event.fragment === fragmentAncestor) {
            trigger(); // ✅ layout-safe now
        }
      });
      } else {
        Reveal.addEventListener('slidechanged', event => {
          if (event.currentSlide.contains(document.getElementById(`${baseId}_dst`))) {
            trigger(); // ✅ safe now
          }
        });
      }
  });
  }

  //////////////////////////////////



document.addEventListener("DOMContentLoaded", () => {
  console.log("JS Functions loaded");

  addNumbersToTables();
  // fixSvgSizes();
  addClassWhenFinalTrigger();
  applyDarkenBackground();
  // setupRevealAnimationsSmart();
  setupRevealTransitions();

});
</script>
