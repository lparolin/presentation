---
title: "Implementing Probabilistic Graphical Models for Online Map Validation in Autonomous Driving Vehicles"
# author: "Dr. Luca Parolini"
format: 
  revealjs:
    theme: [default, styles.scss]
    html: true
    fig-align: left
    slide-number: true
    auto-animate: true
    number-equations: true
    title-slide-attributes:
      data-background-image: "images/map_validation_bmw.png"  # Path to your image
      data-background-size: cover                   # Ensures full coverage
      data-background-position: center              # Optional: centers image
      data-background-opacity: "0.3"
      data-background-color: "black" 


preview:
  watch-inputs: true

---

## 



::: {.spacer-xl}
:::

::: {.spacer-md}
:::

::: {.columns}
::: {.column width="50%"}
A. Fabris, _L. Parolini_, S. Schneider and A. Cenedese, "**Use of probabilistic graphical methods for online map validation**", 2021 - [IEEE Xplore](https://ieeexplore.ieee.org/abstract/document/9669245)

Second Workshop on Online Map Validation and Road Model Creation [**MaVRoC 2021**](https://map-validation.github.io/2021/), IEEE Intelligent Vehicles Symposium - 2021 (IV2021) Nagoya, Japan
:::

::: {.column width="50%"}
![](images/mavroc_screenshot_2021.png){fig-align="left" width=100% fig-alt="MaVRoC 2021"}

:::


:::



::: {.spacer-xl}
:::

::: {.spacer-xl}
:::

In collaboration with Dept. of Information Engineering, University of Padova, Padua, Italy.


## The role of Maps in Autonomous-Driving Vehicle 

- Maps play a central role in Autonomous Driving, allowing trajectory adaptation to upcoming road and lane geometry.

- The *field of view* (FoV) of maps is extremely large and it is **not** affected by traffic conditions or weather.

::: {.columns}
::: {.column width="50%"}
![**Simplified Architecture for Autonomous Driving Vehicles.**](images/information_flow_autonomous_driving){fig-align="left" width=100% fig-alt="Simplified architecture for Autonomous Driving Vehicles."}
:::
:::



:::{.spacer-xs}
:::

::: {.fragment}
Although potentially very accurate, maps provide data with unknown and potentially extensive latency.

Relying on data from an outdated map may lead to uncomfortable, or even unsafe trajectories.
::: 

:::{.callout-note .no-title .fragment .fade-down}
Maps data must be verified **before** they are used for computing future trajectories.
:::

## Different Map Validation Approaches

Depending on the specific application, different approaches to map validation can be considered. ^["F. Drost, A. Fabris, L. *Parolini*, and S. Schneider "Online map validation for autonomous driving", 2020]

<table class="fragmented-table margin-top-mid bottom-border numbered-table top-border">
  <tr>
    <th>#</th>
    <th>Approach</th>
    <th>Details</th>
    <th>Implication</th>
  </tr>
  <tr class="highlightable">
    <td></td>
    <td>**Global Map Invalidation**</td>
    <td>Verifies if a map contain any invalid data. There is no attempt to identify where the map is invalid.</td>
    <td rowspan="2" class="vcenter">A map is valid until proven to be wrong</td>
  </tr>
  <tr class="highlightable">
    <td></td>
    <td>**Local Map Invalidation**</td>
    <td>Attempts to identify which areas of a map contain invalid data</td>
  </tr>
  <tr class="fragment fade-down fragment-index=2">
    <td class="highlightable"></td>
    <td class="highlightable">**Local Map Validation**</td>
    <td class="vcenter highlightable">Every area of a map is invalid until proven to be correct</td>
    <td rowspan="2" class="vcenter">A map is invalid until proven to be correct</td>
  </tr>
  <tr class="fragment fade-down fragment-index=2">
    <td></td>
    <td>**Local Map Correction**</td>
    <td>Use sensor data to correct the map where it is marked as invalid</td>
  </tr>
</table>

:::{.spacer}

:::
::: {.fragment .final-trigger}

In this talk we focus on the problems **1**, **2**, and __3__.
:::
 
## Proposed probabilistic framework {auto-animate="true"}


::: {.columns}
::: {.column width="50%" .mid-space}

::: {.spacer-md}
:::

- Autonomous-driving vehicles are equipped with multiple sensors
  - Each sensor observes a different part of the road

- Different algorithms, combine data from selected sensors and provide an estimation of the map validity in given **areas**
  - We call these algorithms _labelling systems_

- A **correlation-based approach** fuses the results from the different algorithms^[Fabris _et al._ "Correlation-Based Approach to Online Map Validation", MaVRoC 2020, IEEE IV2020] across the different areas and provides a unified view

::: {.spacer-lg}
:::

::: {.fragment}
**In this work, we focus on a labelling system based on _Probabilistic Graphical Models_ (PGMs)**
:::

:::

:::{.column width="50%"}

![](images/prob_framework.png){fig-align="right" width=90% fig-alt="Proposed probabilistic framework"}


![Example of map validation in multiple areas of the road model](images/map_validation_bmw){fig-align="right" width=90% fig-alt="Example of map validation based on correlation"}

:::
:::


## Use Probabilistic Graphical Model for Map Validation

At run-time we divide the portion of a map relevant for trajectory planning into multiple sections.

- Every section is associated with a random variable $\mathcal{M}$ representing the validity of the map in that section.
  - Every section is either: _Valid_, or _Invalid_
- **The values taken by $\mathcal{M}$ are not directly measurable**.


::: {.r-stack style="position: relative; height: 100%;"}
::: {.fragment .fade-in-then-out .no-margin-bottom style="position: absolute; top: 0;"}

Our observable variables are the **matches** between _measured positions of landmarks and of lanes_ provided by sensors, and their _expected positions_ given by the map.

::: {.columns}
::: {.column width="45%" .small-text}
![Lane markings](images/lane_marking_wide.png){fig-align="left" width=100% fig-alt="Example of lane marking" .no-margin-top}

:::


::: {.column width="45%" .small-text}
![Land marks: Traffic lights, building edges, traffic signs.](images/landmarks.png){fig-align="left" width=100% fig-alt="Example of landmarks" .no-margin-top}
:::
:::

:::

::: {.fragment .fade-up style="position: absolute; top: 0;"}
We propose the following _Probabilistic Graphical Model_ (PGM). 

::: {.columns}
::: {.column width="65%"}

```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue];
  Lidar [label="Lidar status"]
  Camera [label="Camera status"]
  Radar [label="Radar status"]


  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity"];
  LandMarkAccuracy [label="Landmark accuracy"];

  Localization[label="Localization\naccuracy"]

  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;
}

```



:::
::: {.column width="35%"}

- Nodes represent random variables
- Edges represent direct influences between random variables

::: {.spacer-sm}
:::

::: 
:::
:::
:::


## Use Probabilistic Graphical Model for Map Validation

At run-time we divide the portion of a map relevant for trajectory planning into multiple sections.

- Every section is associated with a random variable $\mathcal{M}$ representing the validity of the map in that section.
  - Every section is either: _Valid_, or _Invalid_
- **The values taken by $\mathcal{M}$ are not directly measurable**.


We propose the following _Probabilistic Graphical Model_ (PGM). 

::: {.columns}
::: {.column width="65%"}
```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue];
  Lidar [label="Lidar status"]
  Camera [label="Camera status"]
  Radar [label="Radar status"]


  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity"];
  LandMarkAccuracy [label="Landmark accuracy"];

  Localization;
  MeasurableNodeLaneMarking [label="Measurable node", shape=plaintext, fontcolor=darkgreen,  fontsize=18];

  Localization[label="Localization\naccuracy"]


  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;


  // New node + arrow
  MeasurableNodeMap [label="Measurable\lnode\l", shape=plaintext, fontcolor=darkgreen,  fontsize=18, fontname="Helvetica-Bold"];
  MeasurableNodeLandMark [label="Measurable\lnode\l", shape=plaintext, fontcolor=darkgreen,  fontsize=18, fontname="Helvetica-Bold"];
  MeasurableNodeLaneMarking [label="Measurable\lnode\l", shape=plaintext, fontcolor=darkgreen,  fontsize=18, fontname="Helvetica-Bold"];
  
   // Force same horizontal rank
  { rank=same; MeasurableNodeMap; Weather }
   // Force same horizontal rank
  { rank=same; MeasurableNodeLandMark; MeasurableNodeLaneMarking, LaneMarkingMatch, LandMarkMatch }


  MeasurableNodeMap -> Weather [color=darkgreen, penwidth=2];
  MeasurableNodeLandMark -> LandMarkMatch
  MeasurableNodeLaneMarking ->LaneMarkingMatch
}

```

:::
::: {.column width="35%"}

- Nodes represent random variables
- Edges represent direct influences between random variables

::: {.spacer-sm}
:::


- _Weather_, _Lane marking match_, and _Landmark match_ are **measurable nodes**

::: {.spacer-sm}
:::


::: {.fragment}

- All random variables are discrete
:::
:::
:::


## Examples of prior and conditional distributions {auto-animate="true"}

::: {.columns}
::: {.column width="30%" }

:::{data-id="replaceme"}

Prior distributions for **Weather** and **Map validity**

:::{.small-text}
Weather

<table class="top-border bottom-border table-left .tiny-text">
  <tr>
    <td>**Value**</td>
    <td>**Probability**</td>
  </tr>
  <tr>
    <td>_Cooperative_</td>
    <td>0,5</td>
  </tr>
  <tr>
    <td>_Non-cooperative_</td>
    <td>0,5</td>
  </tr>
  
</table>

:::{.spacer-lg}
:::

Map Validity

<table class="top-border bottom-border table-left .tiny-text">
  <tr>
    <td>**Value**</td>
    <td>**Probability**</td>
  </tr>
  <tr>
    <td>_Valid_</td>
    <td>0,8</td>
  </tr>
  <tr>
    <td>_Invalid_</td>
    <td>0,2</td>
  </tr>
  
</table>

:::
:::
:::

:::{.column width="70%"}

```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue, color=darkred, penwidth=5, fontname="Helvetica-Bold"];
  Lidar [label="Lidar status"]
  Camera [label="Camera status"]
  Radar [label="Radar status"]


  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity", color=darkred, penwidth=5, fontname="Helvetica-Bold"];
  LandMarkAccuracy [label="Landmark accuracy"];

  Localization;

  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  Localization[label="Localization\naccuracy"]

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;

}

```

:::
:::


## Examples of prior and conditional distributions {auto-animate="true"}

::: {.columns}
::: {.column width="55%"}

Conditional distributions for Lane marking and Landmark accuracy having high accuracy^[All parameter values available at [GitHub/lparolin/mavroc_2021](https://github.com/lparolin/mavroc_2021/blob/main/mavroc_2021.ipynb)]

:::{data-id="replaceme"}

:::{.small-text}
<table class="top-border bottom-border table-left .tiny-text">
  <tr>
    <td>**Variable**</td>
    <td>**Camera**</td>
    <td>**Radar**</td>
    <td>**Lidar**</td>
    <td>**Probability**</td>
  </tr>
  <tr>
    <td .vcenter rowspan="2" >Lane marking accuracy</td>
    <td>Nominal</td>
    <td>-</td>
    <td>-</td>
    <td>0,85</td>
  </tr>
  <tr>
    <td>**Degraded**</td>
    <td>-</td>
    <td>-</td>
    <td>0,3</td>
  </tr>

  <tr>
    <td .vcenter rowspan="8" >Landmark accuracy</td>
    <td>Nominal</td>
    <td>Nominal</td>
    <td>Nominal</td>
    <td>0,95</td>
  </tr>
  <tr>
    <td>**Degraded**</td>
    <td>Nominal</td>
    <td>Nominal</td>
    <td>0,8</td>
  </tr>
  <tr>
    <td>Nominal</td>
    <td>**Degraded**</td>
    <td>Nominal</td>
    <td>0,8</td>
  </tr>
  <tr>
    <td>**Degraded**</td>
    <td>**Degraded**</td>
    <td>Nominal</td>
    <td>0,4</td>
  </tr>
  <tr>
    <td>Nominal</td>
    <td>Nominal</td>
    <td>**Degraded**</td>
    <td>0,7</td>
  </tr>
  <tr>
    <td>**Degraded**</td>
    <td>Nominal</td>
    <td>**Degraded**</td>
    <td>0,7</td>
  </tr>
  <tr>
    <td>Nominal</td>
    <td>**Degraded**</td>
    <td>**Degraded**</td>
    <td>0,5</td>
  </tr>
  <tr>
    <td>**Degraded**</td>
    <td>**Degraded**</td>
    <td>**Degraded**</td>
    <td>0,01</td>
  </tr>

</table>

:::
:::
:::

:::{.column width="45%"}

:::{.spacer-sm}
:::

:::{.spacer-lg}
:::


```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue];
  Lidar [label="Lidar status"]
  Camera [label="Camera status"]
  Radar [label="Radar status"]


  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy",  color=darkred, penwidth=5, fontname="Helvetica-Bold"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity"];
  LandMarkAccuracy [label="Landmark accuracy", color=darkred, penwidth=5, fontname="Helvetica-Bold"];

  Localization[label="Localization\naccuracy"];

  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;

}

```

:::
:::



## Examples of prior and conditional distributions {auto-animate="true"}

::: {.columns}
::: {.column width="55%"}

Conditional distributions for Localization having high accuracy^[All parameter values available at [GitHub/lparolin/mavroc_2021](https://github.com/lparolin/mavroc_2021/blob/main/mavroc_2021.ipynb)]

:::{data-id="replaceme"}

:::{.small-text}
<table class="top-border bottom-border table-left .tiny-text">
  <tr>
    <td>**Variable**</td>
    <td>**Lane marking accuracy**</td>
    <td>**Map validity**</td>
    <td>**Landmark accuracy is high**</td>
    <td>**Probability**</td>
  </tr>
  
  <tr>
    <td .vcenter rowspan="8" >Localization accuracy</td>
    <td>High</td>
    <td>Valid</td>
    <td>High</td>
    <td>0,95</td>
  </tr>
  <tr>
    <td>High</td>
    <td>Valid</td>
    <td>**Low**</td>
    <td>0,7</td>
  </tr>
  <tr>
    <td>High</td>
    <td>**Invalid**</td>
    <td>High</td>
    <td>0,1</td>
  </tr>
  <tr>
    <td>High</td>
    <td>**Invalid**</td>
    <td>**Low**</td>
    <td>0,1</td>
  </tr>
  <tr>
    <td>**Low**</td>
    <td>Valid</td>
    <td>High</td>
    <td>0,8</td>
  </tr>
  <tr>
    <td>**Low**</td>
    <td>Valid</td>
    <td>**Low**</td>
    <td>0,2</td>
  </tr>
  <tr>
    <td>**Low**</td>
    <td>**Invalid**</td>
    <td>High</td>
    <td>0,1</td>
  </tr>
  <tr>
    <td>**Low**</td>
    <td>**Invalid**</td>
    <td>**Low**</td>
    <td>0,1</td>
  </tr>

</table>

:::
:::
:::

:::{.column width="45%"}

:::{.spacer-sm}
:::

:::{.spacer-lg}
:::


```{dot}
digraph MapValidity {
  rankdir=TB;
  fontname="Helvetica";

  Weather [shape=box, style=filled, fillcolor=lightblue];
  Lidar [label="Lidar status"]
  Camera [label="Camera status"]
  Radar [label="Radar status"]


  Weather -> Lidar;
  Weather -> Camera;
  Weather -> Radar;

  LaneMarkingAccuracy [label="Lane marking accuracy"];
  MapValidity[shape=box, style=filled, fillcolor=lightgrey, label="Map validity"];
  LandMarkAccuracy [label="Landmark accuracy"];

  Localization[label="Localization\naccuracy", color=darkred, penwidth=5, fontname="Helvetica-Bold"];

  Camera -> LaneMarkingAccuracy;
  Camera -> LandMarkAccuracy;
  Radar -> LandMarkAccuracy;
  Lidar -> LandMarkAccuracy;

  LaneMarkingMatch [shape=box, style=filled, fillcolor=lightblue, label="Lane marking match"];
  LandMarkMatch [shape=box, style=filled, fillcolor=lightblue, label="Landmark match"];

  LaneMarkingAccuracy -> Localization;
  MapValidity -> Localization;
  LandMarkAccuracy -> Localization;

  LaneMarkingAccuracy -> LaneMarkingMatch;
  MapValidity -> LaneMarkingMatch;
  Localization -> LaneMarkingMatch;

  LandMarkAccuracy -> LandMarkMatch;
  MapValidity -> LandMarkMatch;
  Localization -> LandMarkMatch;

}

```

:::
:::


## Computation of posterior distribution of Map Validity

For every area, and at every iteration we want to compute

$$
\begin{equation}
P(M =\textrm{Valid}\mid W, S_{\mathrm{lane}}, S_{\mathrm{land}})
=
\frac{P(M, W, S_{\mathrm{lane}}, S_{\mathrm{land}})}
     {P(W, S_{\mathrm{lane}}, S_{\mathrm{land}})},
\label{eq:posterior}
\end{equation}
$$ {#eq-posterior-map}

where 

- $M$ represents the validity of map (valid, invalid)
- $W$ represents the weather status (cooperative, Non-cooperative)
- $S_{\mathrm{lane}}$ represents the matching of lane markings (detected, not-detected) and
- $S_{\mathrm{land}}$ represents the matching of landmarks (detected, not-detected).

:::{.fragment .fade-up}
These probabilities can be obtained from the graphical model by marginalizing over the hidden variables.

- Circa 1k FLOPs per area

:::

:::{.spacer-lg}
:::

:::{.fragment .fade-up}
When all conditional probabilities are constant, then a look-up table approach can be used. 
:::

## Posterior probabilities of high accuracy for different observations {auto-animate="true"}

![](images/posterior_hidden_variables.png){width=90% fig-alt="Posterior probability of high accuracy"}

## Posterior probabilities of high accuracy for different observations {auto-animate="true"}

![](images/posterior_map_validity.png){width=90% fig-alt="Posterior probability of high accuracy and map validity"}

## From a probability distribution to a map classifier

- The algorithm discussed till now, computes the posterior distribution of valid map, given a certain input from the measured nodes
  - We still need a rule to decide if a map is to be _classified_ as valid based on the posterior distribution
  - We focused on a simple classifier based on comparison against a threshold $\lambda$
- A map is valid if the posterior probability of map valid is greater than $\lambda$

![](images/posterior_map_validity.png){width=90% fig-alt="Posterior probability of high accuracy and map validity"}

## Receiver operating characteristic (ROC) curve for the classifier


::: {.columns}
::: {.column width="45%" .mid-space}
:::{.spacer-lg}
:::

- Pairs of _True Positive Rate_ (TPR), _False Positive Rate_ (FPR) for different values of $\lambda$
  - TPR: Probability of declaring a map valid, when it is valid
  - FPR: Probability of declaring a map valid, when it is **not** valid

- The proposed approach is rather insensitive to the value of $\lambda$

:::

::: {.column width="5%" .mid-space}

:::

::: {.column width="50%"}

![](images/roc_curve2.png){fig-alt="ROC Curve"}
:::

:::

# Backup


## Algorithm steps

![**Steps for lane marking match.**](images/Information_flow_lane_marking.svg){width="80%" fig-alt="Information flow lane marking match"}

![**Steps for landmark match.**](images/landmark_match.svg){width="80%" fig-alt="Information flow lane marking match"}


<!-- 

# Introduction to Probabilistic Graphical Methods

## Probabilistic Graphical Models - a Short Review

Probabilistic Graphical Models rely on Graphs for modelling conditional dependencies between random variables.^[Daphne Koller and Nir Friedman. 2009. [Probabilistic Graphical Models: Principles and Techniques - Adaptive Computation and Machine Learning](https://mitpress.ublish.com/book/probabilistic-graphical-models). The MIT Press.]

::: {.example .no-margin-top-first-child}
**Example:**

Suppose we are in a classroom without windows and want to understand if it is raining outside, or not.

We can observe if the professor arrived in the classroom carrying an umbrella and if his/her clothes are wet. 

:::{.fragment}

Based on previous knowledge, we know that:

- The professor tends to carry an umbrella when outside rains;
- If the clothes are wet and the professors does not carry an umbrella, we can be pretty sure that outside is raining.
:::

::: {.fragment}
Based on these observations we can *infer* if outside is raining, or not.
:::

::: {.fragment .fade-down}
The information above can be represented by this PGM:

::: {.column width="50%" id="umbrella_problem_src"}
```{dot}
digraph WeatherProblem {
  rankdir=LR;
  bgcolor="gray95";

  Rain [label="Rain", fontname="Sans-Serif"];

  Rain -> Umbrella;
  Umbrella -> WetClothes;
  Rain -> WetClothes;

  Umbrella [shape=box, style=filled, fillcolor=lightblue, label="Umbrella", fontname="Sans-Serif"];
  WetClothes [shape=box, style=filled, fillcolor=lightblue, label="Wet", fontname="Sans-Serif"];
}

```

:::

::: {.column width="5%"}
:::


::: {.column width="45%" id="text_pgm1_src"}
*Vertices* of the graph represent random variables and *edges* represent conditional dependencies among the variables.

The probability of carrying the umbrella depends on the *realization* of the random variable *Rain*.
:::

:::



:::


## Probabilistic Graphical Models - a Short Review

Probabilistic Graphical Models rely on Graphs for modelling conditional dependencies between random variables.^[Daphne Koller and Nir Friedman. 2009. [Probabilistic Graphical Models: Principles and Techniques - Adaptive Computation and Machine Learning](https://mitpress.ublish.com/book/probabilistic-graphical-models). The MIT Press.]

::: {.example .no-margin-top-first-child}
**Example:**

::: {.column width="50%"}
::: {id="umbrella_problem_dst"}

```{dot}
digraph WeatherProblem {
  rankdir=LR;
  bgcolor="gray95";

  Rain [label="Rain", fontname="Sans-Serif"];

  Rain -> Umbrella;
  Umbrella -> WetClothes;
  Rain -> WetClothes;

  Umbrella [shape=box, style=filled, fillcolor=lightblue, label="Umbrella", fontname="Sans-Serif"];
  WetClothes [shape=box, style=filled, fillcolor=lightblue, label="Wet", fontname="Sans-Serif"];
}

```
:::
:::

::: {.column width="3%"}
:::

::: {.column width="43%"}
::: {style="margin-top:-40px"}
We consider these a priori and conditional probabilities:

::: {.tiny-text}
<table class="top-border bottom-border table-left .tiny-text">
  <tr>
    <td>$\small P(\textrm{Rain=Yes})$</td>
    <td>
      <table class="table-left">
        <tr>
          <td>50%</td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
  <td>
    $\small P(\textrm{Umbrella=Yes}|\small\textrm{Rain})$
  </td>
  <td>
    <table class="table-left">
     <tr>
       <th>Rain=Yes</th>
       <th>Rain=No</th>
     </tr>
     <tr>
       <td>90%</td>
       <td>50%</td>
     </tr>
    </table>
  </td>
  </tr>
  <tr>
  <td>
  $\small P(\textrm{Wet=Yes}|\\\small\phantom{P(}\textrm{Rain,Umbrella})$
</td>
  <td>
  <table class="table-left">
  <tr>
    <th></th>
    <th>Rain=Yes</th>
    <th>Rain=No</th>
  </tr>
  <tr>
    <th>Umbrella=Yes</th>
    <td style="border-top: 1px solid">5%</td>
    <td style="border-top: 1px solid">0.1%</td>
  </tr>
  <tr>
    <th>Umbrella=No</th>
    <td>99%</td>
    <td>0.1%</td>
  </tr>
</table>
</td>
  </tr>
  
</table>

:::
:::
:::

::: {.spacer-sm}
:::

::: {.fragment}
We can infer the following probability of rain, given our observation of wet clothes and umbrella:

<table class="top-border bottom-border table-left .tiny-text">
  <tr>
    <th></th>
    <th>Umbrella=Yes</th>
    <th>Umbrella=No</th>
  </tr>
  <tr>
    <th>Wet=Yes</th>
    <td></td>  
    <td></td>  
  </tr>
  <tr>
    <th>Wet=No</th>
    <td></td>  
    <td></td>  
  </tr>
</table>
 
:::


::: -->

<!-- ::: {.column width=50% .math-compact .left .fragment .small}
These are the set of probabilities we need to define:

$$P(\textrm {Umbrella=Yes} | \textrm{Rain=Yes}) = 0.9 $$
$$P(\textrm {Umbrella=Yes} | \textrm{Rain=No}) = 0.7 $$
$$P(\textrm {Wet=Yes} | \textrm{Rain=No}, \textrm{Umbrella=No}) = 0.01 $$
$$P(\textrm {Wet=Yes} | \textrm{Rain=No}, \textrm{Umbrella=Yes}) = 0.01 $$
$$P(\textrm {Wet=Yes} | \textrm{Rain=Yes}, \textrm{Umbrella=No}) = 0.99 $$
$$P(\textrm {Wet=Yes} | \textrm{Rain=Yes}, \textrm{Umbrella=Yes}) = 0.1 $$
::: -->




<script>
  function addNumbersToTables() {
    document.querySelectorAll(".numbered-table tbody").forEach((tbody) => {
      let count = 1;
      tbody.querySelectorAll("tr").forEach((row) => {
        const cell = row.querySelector("td");
        if (cell) {
          cell.textContent = count++;
        }
      });
    });
  }

  function addClassWhenFinalTrigger(class_to_add = "fragments-complete") {
    if (typeof Reveal !== "undefined") {
      // Add class when final trigger is shown
      Reveal.on("fragmentshown", (event) => {
        if (event.fragment.classList.contains("final-trigger")) {
          const slide = event.fragment.closest(".slide");
          slide.classList.add(class_to_add);
        }
      });

      // Remove class when any fragment is hidden
      Reveal.on("fragmenthidden", (event) => {
        const slide = event.fragment.closest(".slide");
        slide.classList.remove(class_to_add);
      });
    }
  }

  function fixSvgSizes() {
    document.querySelectorAll("svg").forEach((svg) => {
      const g = svg.querySelector("g");
      if (!g) return;

      const bbox = g.getBBox();
      const offsetX = -bbox.x;
      const offsetY = -bbox.y;

      // Set viewBox to start at 0,0
      svg.setAttribute("viewBox", `0 0 ${bbox.width} ${bbox.height}`);
      svg.removeAttribute("width");
      svg.removeAttribute("height");
      svg.style.width = "100%";
      svg.style.height = "auto";

      // Apply transform to shift the <g> into the new origin
      g.setAttribute("transform", `translate(${offsetX}, ${offsetY})`);
    });
  }

  function applyDarkenBackground() {
    document.querySelectorAll('.reveal .slides').forEach(slide => {
      if (slide.querySelector('.darken-background')) {
        slide.classList.add('has-darken-background');
      }
    });
  }


  function animateTransition(srcId, dstId) {
  const src = document.getElementById(srcId);
  const dst = document.getElementById(dstId);
  if (!src || !dst) {
    console.warn('animateTransition: src or dst not found', srcId, dstId);
    return;
  }

  // Remove any previous clone
  document.querySelectorAll('.transition-clone').forEach(el => el.remove());

  const srcRect = src.getBoundingClientRect();
  const dstRect = dst.getBoundingClientRect();

  const dx = dstRect.left - srcRect.left;
  const dy = dstRect.top - srcRect.top;
  const scaleX = dstRect.width / srcRect.width;
  const scaleY = dstRect.height / srcRect.height;

  // Create clone
  const clone = src.cloneNode(true);
  clone.classList.add('transition-clone');
  Object.assign(clone.style, {
    position: 'fixed',
    left: `${srcRect.left}px`,
    top: `${srcRect.top}px`,
    width: `${srcRect.width}px`,
    height: `${srcRect.height}px`,
    margin: '0',
    transform: 'translate(0px, 0px) scale(1, 1)',
    transition: 'transform 0.6s ease-in-out, opacity 0.3s ease-in',
    zIndex: '9999',
    pointerEvents: 'none',
    opacity: '1',
    willChange: 'transform, opacity'
  });

  document.body.appendChild(clone);

  // Hide real dst initially
  dst.style.visibility = 'hidden';

  // Log for diagnostics
  console.log('Initial:', { srcRect, dstRect });

  // Listen for transform transition end on clone
  let transformDone = false;
  clone.addEventListener('transitionend', (e) => {
    if (e.propertyName === 'transform') {
      transformDone = true;
      console.log('transform transition ended; clone bbox:', clone.getBoundingClientRect());
      // After transform ends, we trigger the fade
      // But wait a tiny bit (or next frame) so browser is stable
      requestAnimationFrame(() => {
        // Fade in dst
        dst.style.visibility = 'visible';
        dst.style.opacity = '1';
        dst.style.transition = 'opacity 0.3s ease-in';

        // Fade out the clone
        clone.style.opacity = '0';
      });
    }
  });

  // Start the animation
  requestAnimationFrame(() => {
    console.log('Applying transform:', `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`);
    clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
  });

  // After fade-out ends, clean up
  clone.addEventListener('transitionend', (e) => {
    if (e.propertyName === 'opacity' && transformDone) {
      console.log('opacity transition ended; removing clone; final clone bbox:', clone.getBoundingClientRect(), 'dst bbox:', dst.getBoundingClientRect());
      clone.remove();
    }
  });
}

/**
 * Animate an element moving from srcEl to dstEl,
 * fading out clone during last 20% of movement,
 * and fading in destination element smoothly.
 * 
 * @param {HTMLElement} srcEl - The source element to clone and animate from.
 * @param {HTMLElement} dstEl - The destination element to animate to.
 * @param {Object} [options] - Optional timing settings in ms.
 * @param {number} [options.duration=600] - Total duration of transform animation.
 * @param {number} [options.fadeOutStartRatio=0.8] - When to start fading out clone (as ratio of duration).
 * @param {number} [options.fadeDuration=120] - Duration of clone fade out.
 * @param {number} [options.dstFadeDuration=200] - Duration for destination fade in.
 */
function animateElementTransition(srcId, dstId, options = {}) {
  const {
    duration = 500,
    fadeOutStartRatio = 0.2,
    fadeDuration = 200,
    dstFadeDuration = 900,
  } = options;

  if (!srcId || !dstId) return;
  const srcEl = document.getElementById(srcId);
  const dstEl = document.getElementById(dstId);
  if (!srcEl || !dstEl) {
    console.warn('animateTransition: src or dst not found', srcId, dstId);
    return;
  }
  // Measure source and destination positions/sizes
  const srcRect = srcEl.getBoundingClientRect();
  const dstRect = dstEl.getBoundingClientRect();

  // Hide and set destination opacity 0 initially
  dstEl.style.visibility = 'hidden';
  dstEl.style.opacity = '0';
  dstEl.style.transition = `opacity ${dstFadeDuration}ms ease`;

  // Clone source element
  const clone = srcEl.cloneNode(true);

  Object.assign(clone.style, {
    position: 'fixed',
    top: `${srcRect.top}px`,
    left: `${srcRect.left}px`,
    width: `${srcRect.width}px`,
    height: `${srcRect.height}px`,
    margin: '0',
    transformOrigin: 'top left',
    transition: `transform ${duration}ms ease, opacity ${fadeDuration}ms linear`,
    zIndex: 9999,
    pointerEvents: 'none',
    boxSizing: 'border-box',
    opacity: '1',
    background: 'white', // or adjust for SVG/transparent backgrounds
    willChange: 'transform, opacity',
  });

  document.body.appendChild(clone);
  clone.getBoundingClientRect(); // force reflow

  // Compute transform delta and scale
  const dx = dstRect.left - srcRect.left;
  const dy = dstRect.top - srcRect.top;
  const scaleX = dstRect.width / srcRect.width;
  const scaleY = dstRect.height / srcRect.height;

  // Start transform animation
  requestAnimationFrame(() => {
    clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
  });

  // Schedule fade out of clone starting at fadeOutStartRatio * duration
  setTimeout(() => {
    clone.style.opacity = '0';
  }, duration * fadeOutStartRatio);

  // Cleanup and reveal destination when fade out ends
  clone.addEventListener('transitionend', function onTransitionEnd(e) {
    if (e.propertyName === 'opacity' && clone.style.opacity === '0') {
      // Show and fade in destination
      dstEl.style.visibility = 'visible';
      dstEl.style.opacity = '1';

      clone.removeEventListener('transitionend', onTransitionEnd);
      clone.remove();
    }
  });
}


  function setupRevealTransitions() {
    const srcElements = Array.from(document.querySelectorAll('[id$="_src"]'));

    srcElements.forEach(src => {
      const baseId = src.id.replace(/_src$/, '');
      const dst = document.getElementById(`${baseId}_dst`);
      if (!dst) return;

      const fragmentAncestor = dst.closest('.fragment');

      const trigger = () => {
        requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          //animateTransition(`${baseId}_src`, `${baseId}_dst`);
          animateElementTransition(`${baseId}_src`, `${baseId}_dst`);
          });
        });
      };

      if (fragmentAncestor) {
        Reveal.addEventListener('fragmentshown', event => {
          if (event.fragment === fragmentAncestor) {
            trigger(); // ✅ layout-safe now
        }
      });
      } else {
        Reveal.addEventListener('slidechanged', event => {
          if (event.currentSlide.contains(document.getElementById(`${baseId}_dst`))) {
            trigger(); // ✅ safe now
          }
        });
      }
  });
  }

  //////////////////////////////////



document.addEventListener("DOMContentLoaded", () => {
  console.log("JS Functions loaded");

  addNumbersToTables();
  // fixSvgSizes();
  addClassWhenFinalTrigger();
  applyDarkenBackground();
  // setupRevealAnimationsSmart();
  setupRevealTransitions();

});
</script>
